{
  "hash": "7a7064c311e972bba33a9f2eee8697cb",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Sandbox\"\nauthor: \"Joey Stanley\"\ndate: \"2022-09-04\"\noutput: html_document\n---\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(readxl)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nboard <- read_excel(\"candyland_data.xlsx\", sheet = 1) |> \n  mutate(special = replace_na(special, \"none\")) |> \n  print()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncreate_one_color_card <- function(.color) {\n  c(rep(paste0(\"double \", .color), 4), rep(paste0(\"single \", .color), 6))\n}\ncandy_cards <- c(\"cupcake\", \"ice cream cone\", \"gummy star\", \"gingerbread man\", \"lollipop\", \"popsicle\", \"chocolate truffle\")\ncreate_cards <- function() {\n  tibble(card = c(create_one_color_card(\"red\"),\n                  create_one_color_card(\"purple\"),\n                  create_one_color_card(\"yellow\"),\n                  create_one_color_card(\"blue\"),\n                  create_one_color_card(\"orange\"),\n                  create_one_color_card(\"green\"),\n                  candy_cards)) |> \n    rowid_to_column(\"card_id\")\n}\ncards <- create_cards()\n```\n:::\n\n\n\n\n\n\n## Just copy over from chutes and ladders\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(250304)\nsimulate_game <- function(game_num = 0) {\n  \n  cards <- create_cards()\n  \n  \n  # Declare space for the full game.\n  n_cards <- nrow(cards)\n  turns <- tibble(turn_num = 1:(n_cards*2),\n                  start    = NA,\n                  card_id  = c(sample(1:n_cards, n_cards, replace = FALSE), sample(1:n_cards, n_cards, replace = FALSE)),\n                  shortcut = NA,\n                  end      = NA) |> \n    # Get the card names\n    left_join(cards, by = \"card_id\")\n  \n  # Loop until the game is over\n  i <- 1\n  keep_playing <- TRUE\n  while(keep_playing) {\n\n    # Step 1: Start at zero\n    if (i == 1) {\n      turns$start[[i]] <- 0\n\n    # Otherwise, start where the last turn ended.\n    } else {\n      turns$start[[i]] <- turns$end[[i - 1]]\n    }\n\n    # Step 2: This is where the game actually happens.\n    # If it's a candy card, go straight there.\n    if (turns$card[[i]] %in% candy_cards) {\n      turns$end[[i]] <- board[board$special == turns$card[[i]],]$tile\n      \n    # If it's not, find the next colors.\n    } else {\n      card_color  <- str_extract(turns$card[[i]], \"\\\\w+\\\\Z\")\n      card_amount <- str_extract(turns$card[[i]], \"\\\\A\\\\w+\")\n\n      # move to the next spot\n      eligible_spots <- board |>\n        filter(tile > turns$start[[i]],\n               color == card_color) |>\n        pull(tile)\n      n_eligible_spots <- length(eligible_spots)\n      \n      if (n_eligible_spots >= 2 & card_amount == \"single\") {\n        turns$end[[i]] <- eligible_spots[[1]]\n      } else if (n_eligible_spots >= 2 & card_amount == \"double\") {\n        turns$end[[i]] <- eligible_spots[[2]]\n      } else if (n_eligible_spots == 1 & card_amount == \"single\") {\n        turns$end[[i]] <- eligible_spots[[1]]\n      } else {\n        turns$end[[i]] <- 133\n      }\n    }\n    \n    # Do the shortcuts.\n    if (turns$end[[i]] == 4) {\n      turns$end[[i]] <- 60\n      turns$shortcut[[i]] <- \"peppermint pass\"\n    } else if (turns$end[[i]] == 29) {\n      turns$end[[i]] <- 41\n      turns$shortcut[[i]] <- \"gummy pass\"\n    }\n  \n    # Step 4: Check if it's game over.\n    # run out of cards\n    if (i >= c(n_cards*2)) {\n      keep_playing <- FALSE\n    # win\n    } else if (turns$end[[i]] >= max(board$tile)) {\n      keep_playing <- FALSE\n    } else {\n      i <- i + 1\n    }\n  }\n\n  turns %>%\n    filter(turn_num <= i) %>%\n    return()\n}\nsimulate_game()\n```\n:::\n\n\n\n\n\n## Now simulate lots of games!\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Takes 1.8 minutes for 10K simulations.\nstart_time <- Sys.time()\nset.seed(250304)\ngames <- tibble(game_num = 1:10000) |>\n  mutate(game = map(game_num, simulate_game)) |>\n  unnest(cols = c(game))\nSys.time() - start_time\nbeepr::beep()\n```\n:::\n\n\n\n\n\n\n## Results\n\nNow that we have the simulation done, let's take a look at the results!\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngames_summary <- games %>%\n  summarize(turns = max(turn_num),\n            n_candies = sum(card %in% candy_cards),\n            n_singles = sum(str_detect(card, \"single\")),\n            n_doubles = sum(str_detect(card, \"double\")),\n            n_shortcuts = sum(!is.na(shortcut)),\n            .by = game_num) |> \n  print()\nsummary(games_summary)\n```\n:::\n\n\n\n\n\nFirst, let's look at the number of turns \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(games_summary, aes(turns)) + \n  geom_histogram(binwidth = 1)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(games_summary, aes(n_shortcuts)) + \n  geom_histogram(binwidth = 1)\n\nggplot(games_summary, aes(n_candies)) + \n  geom_histogram(binwidth = 1)\n\nggplot(games_summary, aes(n_singles)) + \n  geom_histogram(binwidth = 1)\n\nggplot(games_summary, aes(n_doubles)) + \n  geom_histogram(binwidth = 1)\n\ngames |> \n  filter(card %in% candy_cards) |> \n  mutate(diff = end - start) |> \n  ggplot(aes(diff)) + \n  geom_histogram(binwidth = 1)\n\ngames |> \n  filter(end != 133) |> \n  ggplot(aes(end)) + \n  geom_histogram(binwidth = 1)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngames |> \n  add_count(name = \"n_turns\", .by = game_num) |> \n  filter(n_turns == max(n_turns))\n```\n:::\n\n\n\n\n\n\n\n\n\n## Visualize the board\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_turn <- function(df, .n, direction) {\n before_turn <- df %>% filter(row_number() < .n)\n pivot_point <- df %>% filter(row_number() == .n)\n after_turn  <- df %>% filter(row_number() > .n)\n \n pivot_x <- pivot_point %>% pull(x)\n pivot_y <- pivot_point %>% pull(y)\n \n if (direction == \"left_north\") {\n   after_turn <- after_turn %>%\n     mutate(y = y + (x - pivot_x),\n            x = pivot_x)\n } else if (direction == \"left_west\") {\n   after_turn <- after_turn %>%\n     mutate(x = pivot_x - (y - pivot_y),\n            y = pivot_x + 1)\n } else if (direction == \"right_north\") {\n   after_turn <- after_turn %>% \n     mutate(y = y + (pivot_x - x),\n            x = pivot_x)\n } else if (direction == \"right_east\") {\n   after_turn <- after_turn %>%\n     mutate(x = x + (y - pivot_y),\n            y = pivot_y)\n }\n bind_rows(before_turn, pivot_point, after_turn)\n}\n\nlayout <- candyland %>%\n  mutate(x = 1:nrow(.),\n         y = 1) %>%\n  add_turn(16, \"left_north\") %>%\n  # add_turn(8, \"left_west\") %>%\n  # add_turn(11, \"right_north\") %>%\n  # add_turn(14, \"right_east\") %>%\n  print()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(layout, aes(x, y, color = color)) + \n  # geom_point(shape = \"square\") + \n  geom_text(aes(label = tile)) + \n  scale_color_identity() + \n  coord_fixed()\n```\n:::\n\n\n\n\n\n\n\n\n\n## Sandbox\n\nCan I do a for loop and just `exit`?\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(250304)\nsimulate_game <- function(game_num = 0) {\n\n  # Declare space for the full game.\n  n_cards <- length(cards)\n  turns <- tibble(turn_num = 1:(n_cards*2),\n                  start    = NA,\n                  card  = c(sample(cards, replace = FALSE), sample(cards, replace = FALSE)),\n                  shortcut = NA,\n                  end      = NA)\n  \n  # Loop until the game is over\n  for (i in 1:nrow(turns)) {\n\n    # Step 1: Start at zero\n    if (i == 1) {\n      turns$start[[i]] <- 0\n\n    # Otherwise, start where the last turn ended.\n    } else {\n      turns$start[[i]] <- turns$end[[i - 1]]\n    }\n\n    # Step 2: This is where the game actually happens.\n    # If it's a candy card, go straight there.\n    if (turns$card[[i]] %in% candy_cards) {\n      turns$end[[i]] <- board[board$special == turns$card[[i]],]$tile\n      \n    # If it's not, find the next colors.\n    } else {\n      card_color  <- str_extract(turns$card[[i]], \"\\\\w+\\\\Z\")\n      card_amount <- str_extract(turns$card[[i]], \"\\\\A\\\\w+\")\n\n      # move to the next spot\n      eligible_spots <- board |>\n        filter(tile > turns$start[[i]],\n               color == card_color) |>\n        pull(tile)\n      n_eligible_spots <- length(eligible_spots)\n      \n      if (n_eligible_spots >= 2 & card_amount == \"single\") {\n        turns$end[[i]] <- eligible_spots[[1]]\n      } else if (n_eligible_spots >= 2 & card_amount == \"double\") {\n        turns$end[[i]] <- eligible_spots[[2]]\n      } else if (n_eligible_spots == 1 & card_amount == \"single\") {\n        turns$end[[i]] <- eligible_spots[[1]]\n      } else {\n        turns$end[[i]] <- 133\n      }\n    }\n    \n    # Do the shortcuts.\n    if (turns$end[[i]] == 4) {\n      turns$end[[i]] <- 60\n      turns$shortcut[[i]] <- \"peppermint pass\"\n    } else if (turns$end[[i]] == 29) {\n      turns$end[[i]] <- 41\n      turns$shortcut[[i]] <- \"gummy pass\"\n    }\n  \n    cat(turns$end[[i]], \" \")\n    \n    # Step 4: Check if it's game over.\n    if (i >= c(n_cards*2)) {\n      keep_playing <- TRUE\n    } else if (turns$end[[i]] >= max(board$tile)) {\n      keep_playing <- TRUE\n    }\n  }\n}\nsimulate_game() |> \n  print()\n```\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}